import * as vscode from "vscode";
import * as utils from "./utils.js";
import * as pathModule from "path";

const defaultConfigPath = pathModule.resolve(__dirname, "..", "defaultConfig.json");
const defaultConfig = utils.ReadFile(defaultConfigPath, true);

export class Session {
    workspace: string;
    config: any;
    rojoConfig: any;
    rojoMap: any;
    watcher: any;

    constructor(workspace, autoStart) {
        this.workspace = workspace;

        // Make sure a src folder exists
        if (!this.fileExists(`src`)) {
            throw new Error(`No src folder found.`);
        }

        // Look for own configuration
        this.config = this.readFile(`.luna.json`);
        if (!this.config) {
            if (!autoStart) {
                this.writeFile(".luna.json", defaultConfig);
            }
            throw new Error(`Could not find configuration so created one for you. Please modify it and try again.`);
        }

        // Look for rojo configuration
        this.rojoConfig = this.readFile(`${this.config.RojoProject}.json`);
        if (!this.rojoConfig) {
            throw new Error(`Could not find rojo project ${this.config.RojoProject}.`);
        }

        // Check if a module with the name already exists to prevent overwrite
        var exists = this.readFile(`src/${this.config.ModuleName}.lua`);
        if (exists && !exists.includes("-- Generated by the Luna extension") && exists != "") {
            throw new Error(
                `Found a lua file already named ${this.config.ModuleName}. Please change one of the names to avoid overwriting.`
            );
        }

        // Create a rojoTreeMap
        this.rojoMap = utils.MapRojoTree(this.rojoConfig.tree);

        // Create fileSystemWatcher
        const watcher = vscode.workspace.createFileSystemWatcher("**/*.lua", false, false, false);
        const refreshFunc = this.refresh.bind(this);
        watcher.onDidChange(refreshFunc);
        watcher.onDidCreate(refreshFunc);
        watcher.onDidDelete(refreshFunc);
        this.watcher = watcher;
        refreshFunc();

        console.log(`Successfully created new session in ${this.workspace}`);
    }

    cleanup() {
        this.watcher.dispose();
    }

    writeFile(path: string, contents: string) {
        return utils.WriteFile(`${this.workspace}/${path}`, contents);
    }
    readFile(path: string) {
        return utils.ReadFile(`${this.workspace}/${path}`);
    }
    fileExists(path: string) {
        return utils.FileExists(`${this.workspace}/${path}`);
    }

    // Refreshes everything
    refresh(uri?: vscode.Uri) {
        if (uri && uri.path.endsWith(`/src/${this.config.ModuleName}.lua`)) return; // don't detect changes on own module

        const workspace = this.workspace;
        const config = this.config;
        const rojoMap = this.rojoMap;
        const sourceMap = utils.BuildFileMap(`${this.workspace}/src`);

        const lines = [
            `-- Generated by the Luna extension`,
            `-- Last edited ${new Date()}`,
            ``,
            `local modules = {}`,
            ``,
        ];

        const categories = {};
        function addCategory(name) {
            if (categories[name]) return;
            categories[name] = true;
            lines.push(`modules.${name} = {}`);
        }

        function traverse(files) {
            files.forEach((file) => {
                if (file.type == "module") {
                    if (file.path == `${workspace}/src/${config.ModuleName}.lua`.replace(/\//g, "\\")) return; // don't add self

                    const inGamePath = `${utils.GetGamePath(file.path, rojoMap)}.${file.name}`;

                    function fileIsIn(directoryPath) {
                        directoryPath = `${workspace}/src/${directoryPath}`.replace(/\//g, "\\");
                        return file.path.startsWith(directoryPath);
                    }

                    // check IndexedFolders
                    let index;
                    config.IndexedFolders.forEach((directoryPath) => {
                        directoryPath = directoryPath.replace(/\//g, "\\");
                        if (fileIsIn(directoryPath)) {
                            const split = directoryPath.split("\\");
                            index = split[split.length - 1];
                        }
                    });
                    if (index) {
                        addCategory(index);
                    }

                    // check client / server restricted
                    var restricted: boolean | string = false;
                    function checkRestriction(directoryPath: string, side: string) {
                        directoryPath = directoryPath.replace(/\//g, "\\");
                        if (fileIsIn(directoryPath)) {
                            if (restricted) {
                                // restricted to both, so it is shared
                                restricted = false;
                                return;
                            }
                            restricted = side;
                        }
                    }
                    config.ServerRestricted.forEach((directoryPath) => checkRestriction(directoryPath, "Server"));
                    config.ClientRestricted.forEach((directoryPath) => checkRestriction(directoryPath, "Client"));

                    let line = `modules.${index ? index + "." : ""}${file.name} = require(${inGamePath})`;
                    if (restricted) {
                        line = `if game:GetService("RunService"):Is${restricted}() then\n	${line}\nend`;
                    }

                    lines.push(line);
                } else if (file.type == "directory") {
                    traverse(file.children);
                }
            });
        }

        traverse(sourceMap);

        lines.push(``);
        lines.push(`return modules`);

        this.writeFile(`src/${config.ModuleName}.lua`, lines.join(`\n`));
    }
}
